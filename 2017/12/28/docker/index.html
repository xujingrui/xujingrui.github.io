<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Docker虚拟化 • My Blog</title><meta name="description" content="Docker虚拟化 - XuJingRui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="My Blog"></head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="My Blog">My Blog</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/xujingrui" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Docker虚拟化</h1><div class="post-info"><a></a>2017-12-28</div><div class="post-content"><h2 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3141540493,1060669034&amp;fm=27&amp;gp=0.jpg" alt="aaa"></p>
<h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><blockquote>
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li>
</ul>
</blockquote>
<h3 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h3><ul>
<li><strong>1、简化程序：</strong><br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的    任务，在Docker容器的处理下，只需要数秒就能完成。</li>
<li><strong>2、避免选择恐惧症：</strong><br>如果你有选择恐惧症，还是资深患者。Docker 帮你    打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</li>
<li><strong>3、节省开支：</strong><br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</li>
</ul>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><blockquote>
<ul>
<li>Docker安装需要Linux内核3.0以上版本。</li>
<li>建议安装在Centos7版本以上的系统。</li>
<li>打开Linux系统路由转发功能</li>
</ul>
</blockquote>
<p>打开路由转发功能方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;net.ipv4.ip_forward = 1 &apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td>CentOS Linux release 7.3.1611</td>
</tr>
<tr>
<td>Docker</td>
<td>17.09.1-ce</td>
</tr>
</tbody>
</table>
<p>下载Docker源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.docker.com/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>安装Docker:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure>
<p>版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker -v</span><br><span class="line">Docker version 17.09.1-ce, build 19e2cf6</span><br></pre></td></tr></table></figure>
<p>添加国内加速：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;&#123;&quot;registry-mirrors&quot;: [&quot;http://a91c78ed.m.daocloud.io&quot;]&#125;&apos; &gt; /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<p>开机启动服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start  docker</span><br><span class="line">systemctl enable  docker</span><br></pre></td></tr></table></figure>
<p>运行一个容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p>看到以上信息证明Docker安装成功</p>
<p><img src="https://raw.githubusercontent.com/xujingrui/xujingrui.github.io/master/home/images/docker-1.jpg" alt="aa-1"></p>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><blockquote>
<ul>
<li>1.镜像管理</li>
<li>2.容器管理</li>
<li>3.容器使用</li>
<li>4.常用例子</li>
</ul>
</blockquote>
<hr>
<h3 id="1-镜像管理"><a href="#1-镜像管理" class="headerlink" title="1.镜像管理"></a>1.镜像管理</h3><p>查找一个镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &quot;Image Name&quot;</span><br></pre></td></tr></table></figure>
<p>下载一个镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &quot;Image Name&quot;</span><br></pre></td></tr></table></figure>
<p>查看一个镜像构建信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &quot;Image Name&quot;</span><br></pre></td></tr></table></figure>
<p>查看本地镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>将容器生成镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &quot;Container Name&quot; &quot;Image Name&quot;</span><br></pre></td></tr></table></figure>
<p>修改镜像信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag &quot;Source Image Name&quot; &quot;New Image Name&quot;</span><br></pre></td></tr></table></figure>
<p>使用Dockerfile构建一个镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &quot;Image Name&quot; &quot;Dockerfile Dir&quot;</span><br></pre></td></tr></table></figure>
<p>上传本地镜像到Registry仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push &quot;Image Name&quot;</span><br></pre></td></tr></table></figure>
<p>删除一个镜像,-f是强制删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f &quot;Image Name&quot;</span><br></pre></td></tr></table></figure>
<p>删除所有镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep none | awk &apos;&#123;print $3&#125;&apos; | sort -r)</span><br></pre></td></tr></table></figure>
<h3 id="2-容器管理"><a href="#2-容器管理" class="headerlink" title="2.容器管理"></a>2.容器管理</h3><p>查看运行中的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>查看所有容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>查看一个容器里的进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top &quot;Container Name&quot;</span><br></pre></td></tr></table></figure>
<p>将一个容器启动、停止、重启、资源状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start|stop|restart|stats &quot;Container Name&quot;</span><br></pre></td></tr></table></figure>
<p>将容器里面的文件拷贝出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &quot;Container Name&quot;:&quot;File or Dir Path&quot; &quot;Host Path&quot;</span><br></pre></td></tr></table></figure>
<p>删除一个容器，-f是强制删除:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f &quot;Container Name&quot;</span><br></pre></td></tr></table></figure>
<p>删除所有容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h3 id="3-容器使用"><a href="#3-容器使用" class="headerlink" title="3.容器使用"></a>3.容器使用</h3><p>启动一个容器的常规参数：<code>docker run [Options]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -v &quot;Host Path&quot;:&quot;Container Name File or Dir Path&quot;  \</span><br><span class="line">-p &quot;Host Port&quot;:&quot;Container Port&quot; --net=&quot;host&quot; -e &quot;Environment&quot;=&quot;Value&quot; \</span><br><span class="line">--name &quot;Container Name&quot;  &quot;Image Name&quot;  &quot;Command&quot;</span><br><span class="line"></span><br><span class="line">命令解释：</span><br><span class="line">-i：标准输入给容器、-t：分配一个虚拟终端 （-it一起组合使用）   </span><br><span class="line">-d：以守护进程方式运行，后台启动（不能和-it一起使用）</span><br><span class="line">-v：宿主机目录或文件挂载到容器里面</span><br><span class="line">-P：默认匹配docker容器的5000端口号到宿主机的49153 to 65535端口</span><br><span class="line">-p：&lt;HOT_PORT&gt;:&lt;CONTAINER_PORT&gt;：指定端口号（-P和-p只能选一种）</span><br><span class="line">--net：指定容器使用的网络，默认是Bridge</span><br><span class="line">    - bridge：是容器的默认网络，可以配置后与宿主机通信从而与互联网互联互通</span><br><span class="line">    - host: 和宿主机共用一个网络</span><br><span class="line">    - none：不为Docker容器进行任何网络配置 </span><br><span class="line">-e: 设置环境变量</span><br><span class="line">--name：指定容器的名称</span><br><span class="line">Image Name：使用那个镜像创建容器</span><br><span class="line">Command：Bash脚本命令</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">docker run -d -v /etc/hosts:/etc/hosts -p 80:8080  \</span><br><span class="line">--net=&quot;bridge&quot; -e JAVA_HOME=/data/jdk \</span><br><span class="line">--name test1 zabbix/zabbix-server-mysql</span><br></pre></td></tr></table></figure>
<p>维护一个容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &quot;Container Name&quot; &quot;Command&quot;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">docker exec -it test1 bash</span><br></pre></td></tr></table></figure>
<h2 id="Dockerfile自定义镜像"><a href="#Dockerfile自定义镜像" class="headerlink" title="Dockerfile自定义镜像"></a>Dockerfile自定义镜像</h2><p>Dockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令。Docker程序将这些Dockerfile指令翻译真正的Linux命令。Dockerfile有自己书写格式和支持的命令，Docker程序解决这些命令间的依赖关系，类似于Makefile。
　　</p>
<p>Docker程序将读取Dockerfile，根据指令生成定制的image。相比image这种黑盒子，Dockerfile这种显而易见的脚本更容易被使用者接受，它明确的表明image是怎么产生的。有了Dockerfile，当我们需要定制自己额外的需求时，只需在Dockerfile上添加或者修改指令，重新生成image即可，省去了敲命令的麻烦。</p>
<h3 id="Dockerfile语法"><a href="#Dockerfile语法" class="headerlink" title="Dockerfile语法"></a>Dockerfile语法</h3><ul>
<li>1、FROM（第一条指令必须是FROM） 格式：FROM 或 FROM </li>
<li>2、MAINTAINER 格式：MAINTAINER #指定维护者信息</li>
<li>3、RUN 格式：RUN 或 RUN [“executable”,”param1”,”param2”] #前者将在shell终端运行，后者则使用exec 执行；</li>
<li>4、CMD 格式：（三种格式） CMD [“executable”,”param1”,”param2”] #使用exec 执行，推荐使用； CMD command param1 param2 #在/bin/bash中执行，提供给需要交互的应用； CMD [“param1”,”param2”] #提供给ENTRYPOINT 默认参数 每个Dockerfile 文件只能有一个CMD 命令，如果指定多了多条命令，只有最后一条被执行；如果用户启动容器的时候指定了运行命令，则会覆盖掉CMD指定的命令；</li>
<li>5、EXPOSE 格式：EXPOSE [ …] #告诉Docker 服务端容器暴露的端口号，供互联系统使用； 例：EXPOSE 22 80 8443</li>
<li>6、ENV 格式：ENV #指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。</li>
<li>7、ADD 格式：ADD #复制指定的src 到容器的dest ，其中src 可以是Dockerfile 所在目录的一个相对路径（文件或目录）；也可以是个URL 还可以是一个tar 文件（自动解压为目录）。</li>
<li>8、COPY 格式：COPY #复制本地主机的src 到容器中的dest 。目标路径不存在时，会自动创建。当时用本地目标为源目录时，推荐使用COPY。</li>
<li>9、ENTRYPOINT 格式：（两种格式） ENTRYPOINT [“executable”,”param1”,”param2”] ENTRYPOINT command param1 param2 #配置容器启动后执行的命令，并且不可被docker run 提供的参数覆盖。每个Dockerfile 中只能有一个ENTRYPOINT ，当指定多个后，只有最后一个生效</li>
<li>10、VOLUME 格式：VOLUME [“/data”] #创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</li>
<li>11、USER 格式：USER daemon #指定运行容器时的用户名或UID ，后续的RUN 也会使用指定用户。</li>
<li><p>12、WORKDIR 格式：WORKDIR /path/to/workdir #为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例： WORKDIR /a WORKDIR b WORKDIR c RUN pwd 则最终为：/a/b/c</span><br></pre></td></tr></table></figure>
</li>
<li><p>13、ONBUILD 格式：ONBUILD [INSTRUCTION] #配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作命令。<br>docker build #根据指定路径下的Dockerfile 创建镜像。</p>
</li>
</ul>
<h3 id="Dockerfile例子"><a href="#Dockerfile例子" class="headerlink" title="Dockerfile例子"></a>Dockerfile例子</h3><p>查目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/DockerFile</span><br><span class="line">└── base</span><br><span class="line">    ├── dockerfile</span><br><span class="line">    └── jenkins.war</span><br></pre></td></tr></table></figure>
<p>查看dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cat /DockerFile/base/dockerfile </span><br><span class="line"># dockerfile build image</span><br><span class="line">FROM centos:latest</span><br><span class="line"></span><br><span class="line">MAINTAINER xujingrui_xjr@163.com</span><br><span class="line"></span><br><span class="line">RUN mkdir /data ; yum install  -y java</span><br><span class="line"></span><br><span class="line">COPY jenkins.war /data/</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT java -jar /data/jenkins.war</span><br></pre></td></tr></table></figure>
<p>构建自定义镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t jenkins:1.0 /DockerFile/base/</span><br></pre></td></tr></table></figure>
<p>查看刚创建的镜像jenkins:1.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">jenkins             1.0                 56f0361fe285        2 minutes ago       508MB</span><br></pre></td></tr></table></figure>
<p>运行jenkins镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker run -d -p 12345:8080 jenkins:1.0 </span><br><span class="line">7a4e64a266feb756f7cbe6889df9bd818976e8280d7dc082afffbc9e1d3f7f6f</span><br><span class="line"></span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">7a4e64a266fe        jenkins:1.0         &quot;/bin/sh -c &apos;java ...&quot;   30 seconds ago      Up 29 seconds       0.0.0.0:12345-&gt;8080/tcp   cocky_lovelace</span><br></pre></td></tr></table></figure>
<p>访问jenkins:</p>
<p><img src="https://raw.githubusercontent.com/xujingrui/xujingrui.github.io/master/home/images/jenkins-8.jpg" alt="aa-2"></p>
<hr>
<p><strong>后续还有更多Docker高级玩法</strong></p>
<hr>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2017/12/30/Jenkins/">prev</a><a class="next" href="/2017/12/27/saltstack/">next</a></div><div class="copyright"><p>&copy; 2012 - 2018 <a href="/about">XuJingRui</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-X']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>